# Phase 3.2: Fix Scorer False Positives

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Eliminate 4 false-positive bugs that undermine scorer credibility — openkraft should score itself honestly.

**Architecture:** All fixes are in the scoring layer (`internal/domain/scoring/`) except Bug 3 which also touches the parser. No new files needed.

**Tech Stack:** Go, go/ast, camelcase library

---

## Context

Running `./openkraft score .` on itself reveals 4 false-positive bugs:

| Bug | Metric | Symptom | Impact |
|-----|--------|---------|--------|
| 1 | `self_describing_names` | 0/244 functions pass | Entire sub-metric broken |
| 2 | `dependency_direction` | 17 violations from test files | 0/25 on a clean project |
| 3 | `explicit_dependencies` | 37 "global vars" are immutable styles | 0/25 for UI package |
| 4 | `predictable_structure` | suffixes=0% despite layers=100% | Drags score by ~8 pts |

---

## Task 1: Fix `hasVerbNounPattern` — accept common Go verbs

The current allowlist has only 14 verbs. Functions like `Score`, `Analyze`, `New`, `Compute`, `Apply`, `Load`, `Save`, `Check`, `Build`, `Render`, `Format`, `Write`, `Read`, `Open`, `Close`, `Start`, `Stop`, `Init`, `Register`, `Handle`, `Detect`, `Scan`, `Extract`, `Filter`, `Sort`, `Merge`, `Split`, `Wrap`, `Collect`, `Resolve`, `Set`, `Add`, `Remove`, `Is`, `Has`, `Can`, `Should`, `Must`, `With` all fail.

**Files:**
- Modify: `internal/domain/scoring/naming.go` — `specificPrefixes` map and `hasVerbNounPattern`
- Modify: `internal/domain/scoring/naming_test.go` — add test cases

**Step 1: Write failing test**

Add to `naming_test.go`:

```go
func TestHasVerbNounPattern_CommonGoVerbs(t *testing.T) {
	passing := []string{
		"ScoreCodeHealth", "AnalyzeFile", "NewScoreService",
		"ComputeOverallScore", "LoadConfig", "SaveResult",
		"CheckModule", "BuildReport", "RenderScore",
		"WriteFile", "ReadConfig", "OpenConnection",
		"StartServer", "StopWorker", "RegisterHandler",
		"DetectModules", "ScanProject", "ExtractErrors",
		"FilterFiles", "SortResults", "CollectIssues",
		"ResolveImport", "SetWeight", "AddCategory",
		"RemoveSkipped", "ApplyConfig", "FormatOutput",
		"HandleRequest", "ProcessEvent", "RunPipeline",
		"IsValid", "HasPrefix", "MarshalJSON",
	}
	for _, name := range passing {
		assert.True(t, scoring.HasVerbNounPattern(name), "%s should match verb+noun", name)
	}
}

func TestHasVerbNounPattern_Rejects(t *testing.T) {
	failing := []string{
		"X",           // single word
		"",            // empty
		"lower",       // unexported
		"A",           // single letter
	}
	for _, name := range failing {
		assert.False(t, scoring.HasVerbNounPattern(name), "%s should NOT match", name)
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/domain/scoring/ -run TestHasVerbNounPattern_CommonGoVerbs -v`
Expected: FAIL — most names rejected by the narrow allowlist.

**Step 3: Implement fix**

Replace `hasVerbNounPattern` in `naming.go`:

The fix: **any exported name with 2+ CamelCase words is verb+noun**. The first word of an exported Go function is almost always a verb by convention (`Get`, `Set`, `New`, `Create`, `Score`, etc.). Single-word names (`String`, `Error`, `Len`) fail because they have <2 words. This matches Go community conventions and the Go naming guidelines.

```go
// hasVerbNounPattern checks if an exported function name has at least 2
// CamelCase words (verb + noun). This follows Go naming conventions where
// exported function names naturally use verb+noun structure.
func hasVerbNounPattern(name string) bool {
	if len(name) == 0 || !unicode.IsUpper(rune(name[0])) {
		return false
	}
	words := camelcase.Split(name)
	return len(words) >= 2
}
```

Also export it for testing:

```go
// HasVerbNounPattern is the exported version for testing.
var HasVerbNounPattern = hasVerbNounPattern
```

Delete the `specificPrefixes` map — it's no longer used.

**Step 4: Run tests**

Run: `go test ./internal/domain/scoring/ -run "TestHasVerbNounPattern|TestScorePredictability" -v`
Expected: All PASS.

**Step 5: Verify impact**

Run: `go build -o ./openkraft ./cmd/openkraft && ./openkraft score . --json | python3 -c "import sys,json; d=json.load(sys.stdin); [print(f'{c[\"name\"]}: {c[\"score\"]}') for c in d['categories']]"`

`self_describing_names` should now show a realistic ratio (probably 60-80% of 244 functions).

---

## Task 2: Exclude `_test.go` from dependency direction checks

Test files legitimately import concrete implementations for integration testing. The scorer should only audit production code.

**Files:**
- Modify: `internal/domain/scoring/discoverability.go` — `scoreDiscoverabilityDependencyDirection` and `collectDiscoverabilityIssues`
- Modify: `internal/domain/scoring/discoverability_test.go` — add test

**Step 1: Write failing test**

Add to `discoverability_test.go`:

```go
func TestScoreDiscoverability_TestFileImportsNotCounted(t *testing.T) {
	modules := []domain.DetectedModule{
		{
			Name:   "user",
			Path:   "internal/user",
			Layers: []string{"domain"},
			Files: []string{
				"internal/user/domain/model.go",
				"internal/user/domain/model_test.go",
			},
		},
	}
	analyzed := map[string]*domain.AnalyzedFile{
		"internal/user/domain/model.go": {
			Path:    "internal/user/domain/model.go",
			Package: "domain",
			Imports: []string{"fmt"},
		},
		"internal/user/domain/model_test.go": {
			Path:    "internal/user/domain/model_test.go",
			Package: "domain_test",
			Imports: []string{"internal/user/adapters/db"}, // test importing adapter — OK
		},
	}

	result := scoring.ScoreDiscoverability(modules, &domain.ScanResult{}, analyzed)

	depDirection := result.SubMetrics[3]
	assert.Equal(t, "dependency_direction", depDirection.Name)
	assert.Equal(t, depDirection.Points, depDirection.Score,
		"test file imports should not count as violations")

	// No issues from test files.
	for _, issue := range result.Issues {
		assert.NotContains(t, issue.File, "_test.go",
			"test files should not generate dependency violations")
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/domain/scoring/ -run TestScoreDiscoverability_TestFileImportsNotCounted -v`
Expected: FAIL — test file import counted as violation.

**Step 3: Implement fix**

In `scoreDiscoverabilityDependencyDirection`, add filter after `for _, f := range m.Files {`:

```go
if strings.HasSuffix(f, "_test.go") {
	continue
}
```

Same filter in `collectDiscoverabilityIssues`, after `for _, f := range m.Files {`:

```go
if strings.HasSuffix(f, "_test.go") {
	continue
}
```

**Step 4: Run tests**

Run: `go test ./internal/domain/scoring/ -run TestScoreDiscoverability -v`
Expected: All PASS.

---

## Task 3: Don't penalize unexported package-level vars in `explicit_dependencies`

The issue is that immutable style vars (`var accent = lipgloss.Color(...)`) are counted the same as mutable singletons (`var db *sql.DB`). The simplest correct fix: **only count exported global vars**. Unexported package-level vars are implementation details — they don't create implicit dependencies across package boundaries. Exported ones like `var ErrNotFound` are sentinel errors and should still be counted (but they're usually few).

However, sentinel errors (`Err*` prefix) are a Go convention and shouldn't be penalized either. So: count only exported vars that aren't sentinel errors.

**Files:**
- Modify: `internal/domain/scoring/predictability.go` — `scoreExplicitDependencies`
- Modify: `internal/domain/scoring/predictability_test.go` — add test

**Step 1: Write failing test**

Add to `predictability_test.go`:

```go
func TestScorePredictability_UnexportedVarsNotPenalized(t *testing.T) {
	analyzed := map[string]*domain.AnalyzedFile{
		"renderer.go": {
			Path:    "renderer.go",
			Package: "tui",
			// These are all unexported style vars — should not be penalized.
			GlobalVars: []string{
				"accent", "fg", "dim", "faint", "success", "danger",
				"headerStyle", "boxStyle", "dimStyle", "faintStyle",
			},
		},
	}

	result := scoring.ScorePredictability(nil, nil, analyzed)

	explDeps := result.SubMetrics[1]
	assert.Equal(t, "explicit_dependencies", explDeps.Name)
	assert.Equal(t, explDeps.Points, explDeps.Score,
		"unexported vars should not reduce score")
}

func TestScorePredictability_ExportedNonSentinelVarsPenalized(t *testing.T) {
	analyzed := map[string]*domain.AnalyzedFile{
		"global.go": {
			Path:    "global.go",
			Package: "app",
			GlobalVars: []string{
				"DB",          // exported mutable — penalize
				"Logger",      // exported mutable — penalize
				"ErrNotFound", // sentinel error — skip
				"config",      // unexported — skip
			},
		},
	}

	result := scoring.ScorePredictability(nil, nil, analyzed)

	explDeps := result.SubMetrics[1]
	assert.Equal(t, "explicit_dependencies", explDeps.Name)
	// Only DB + Logger = 2 penalized, 2 * 3 = 6 penalty. 25 - 6 = 19.
	assert.Equal(t, 19, explDeps.Score)
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/domain/scoring/ -run "TestScorePredictability_UnexportedVars|TestScorePredictability_ExportedNonSentinel" -v`
Expected: FAIL.

**Step 3: Implement fix**

In `scoreExplicitDependencies`, change the counting logic:

```go
for _, af := range analyzed {
	if strings.HasSuffix(af.Path, "_test.go") {
		continue
	}
	totalFiles++
	for _, gv := range af.GlobalVars {
		// Only penalize exported vars that aren't sentinel errors.
		if len(gv) > 0 && unicode.IsUpper(rune(gv[0])) && !strings.HasPrefix(gv, "Err") {
			mutableState++
		}
	}
	mutableState += af.InitFunctions
}
```

Add `"unicode"` to imports.

**Step 4: Run tests**

Run: `go test ./internal/domain/scoring/ -run TestScorePredictability -v`
Expected: All PASS. Check that existing `TestScorePredictability_MutableStateReducesScore` still passes — it uses `GlobalVars: []string{"db", "logger", "config", "cache", "mutex"}` which are all unexported, so its expected score will change.

**Step 4b: Update existing test**

`TestScorePredictability_MutableStateReducesScore` has 5 unexported vars + 2 inits. With the fix, only the 2 inits are penalized: 2 * 3 = 6, score = 25 - 6 = 19. Update the assertion:

```go
assert.Equal(t, 19, explDeps.Score)
```

**Step 5: Run all tests**

Run: `go test ./internal/domain/scoring/ -v`
Expected: All PASS.

---

## Task 4: Fix `predictable_structure` suffix signal for projects without suffixed filenames

When modules have files like `model.go`, `service.go` (no underscore), the suffix set is empty and Jaccard returns 1.0 (both empty = match). But when some have underscore-suffixed files and others don't, it breaks. The real issue: the suffix signal (30% weight) contributes nothing useful when a project doesn't use underscore-naming. The fix: when a module has no suffixed files, use the **base filename** (without `.go`) as the comparison element instead. This compares files like `model.go` across modules directly.

**Files:**
- Modify: `internal/domain/scoring/discoverability.go` — `scorePredictableStructure`
- Modify: `internal/domain/scoring/discoverability_test.go` — add test

**Step 1: Write failing test**

Add to `discoverability_test.go`:

```go
func TestScoreDiscoverability_PredictableStructureWithoutSuffixes(t *testing.T) {
	// Modules have matching filenames but no underscore suffixes.
	modules := []domain.DetectedModule{
		{
			Name:   "user",
			Path:   "internal/user",
			Layers: []string{"domain", "application"},
			Files: []string{
				"internal/user/domain/model.go",
				"internal/user/application/service.go",
			},
		},
		{
			Name:   "order",
			Path:   "internal/order",
			Layers: []string{"domain", "application"},
			Files: []string{
				"internal/order/domain/model.go",
				"internal/order/application/service.go",
			},
		},
	}

	result := scoring.ScoreDiscoverability(modules, &domain.ScanResult{}, nil)

	predictable := result.SubMetrics[2]
	assert.Equal(t, "predictable_structure", predictable.Name)
	assert.GreaterOrEqual(t, predictable.Score, 20,
		"modules with matching filenames should score high even without suffixes")
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/domain/scoring/ -run TestScoreDiscoverability_PredictableStructureWithoutSuffixes -v`
Expected: FAIL or low score because suffix sets are empty → Jaccard returns 1.0 but files without underscores are excluded.

**Step 3: Implement fix**

In `scorePredictableStructure`, modify the suffix extraction loop. When a file has no underscore, use the full base name as the comparison element:

```go
suffixSets[i] = make(map[string]bool)
nonTestFiles := 0
for _, f := range m.Files {
	base := filepath.Base(f)
	name := strings.TrimSuffix(base, ".go")
	if strings.HasSuffix(name, "_test") {
		continue
	}
	nonTestFiles++
	if idx := strings.LastIndex(name, "_"); idx >= 0 {
		suffixSets[i][name[idx:]] = true
	} else {
		// No underscore — use the full filename as comparison element.
		suffixSets[i][name] = true
	}
}
```

**Step 4: Run tests**

Run: `go test ./internal/domain/scoring/ -run TestScoreDiscoverability -v`
Expected: All PASS.

---

## Execution Order

1. Task 1 (verb+noun pattern) — biggest impact, 0/244 → realistic ratio
2. Task 2 (test file filter) — 17 false violations → 0
3. Task 3 (unexported vars) — 37 false penalizations → realistic count
4. Task 4 (suffix fallback) — suffixes 0% → matches actual structure

## Verification

After all 4 tasks:

```bash
go clean -testcache
go test ./... -race -count=1
go build -o ./openkraft ./cmd/openkraft
./openkraft score . --json
```

Expected: overall score rises from 60 to ~75-80. No category should have a 0/25 sub-metric for a false positive reason.
