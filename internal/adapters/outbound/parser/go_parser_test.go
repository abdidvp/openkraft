package parser_test

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/openkraft/openkraft/internal/adapters/outbound/parser"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

const taxRulePath = "../../../../testdata/go-hexagonal/perfect/internal/tax/domain/tax_rule.go"
const taxPortsPath = "../../../../testdata/go-hexagonal/perfect/internal/tax/application/tax_ports.go"

func TestGoParser_FindsStructs(t *testing.T) {
	p := parser.New()
	result, err := p.AnalyzeFile(taxRulePath)
	require.NoError(t, err)

	assert.Contains(t, result.Structs, "TaxRule")
}

func TestGoParser_FindsFunctions(t *testing.T) {
	p := parser.New()
	result, err := p.AnalyzeFile(taxRulePath)
	require.NoError(t, err)

	funcNames := make([]string, len(result.Functions))
	for i, f := range result.Functions {
		funcNames[i] = f.Name
	}
	assert.Contains(t, funcNames, "NewTaxRule")
}

func TestGoParser_FindsMethods(t *testing.T) {
	p := parser.New()
	result, err := p.AnalyzeFile(taxRulePath)
	require.NoError(t, err)

	var validateFunc *struct{ name, receiver string }
	for _, f := range result.Functions {
		if f.Name == "Validate" {
			validateFunc = &struct{ name, receiver string }{f.Name, f.Receiver}
			break
		}
	}
	require.NotNil(t, validateFunc, "should find Validate method")
	assert.Equal(t, "*TaxRule", validateFunc.receiver)
}

func TestGoParser_FindsInterfaces(t *testing.T) {
	p := parser.New()
	result, err := p.AnalyzeFile(taxPortsPath)
	require.NoError(t, err)

	assert.Contains(t, result.Interfaces, "TaxRuleRepository")
}

func TestGoParser_ExtractsInterfaceMethods(t *testing.T) {
	p := parser.New()
	af, err := p.AnalyzeFile(taxPortsPath)
	require.NoError(t, err)
	assert.NotEmpty(t, af.InterfaceDefs)
	for _, iface := range af.InterfaceDefs {
		assert.NotEmpty(t, iface.Methods, "interface %s should have methods", iface.Name)
	}
}

func TestGoParser_FindsImports(t *testing.T) {
	p := parser.New()
	result, err := p.AnalyzeFile(taxRulePath)
	require.NoError(t, err)

	assert.Contains(t, result.Imports, "errors")
	assert.Contains(t, result.Imports, "time")
}

func TestGoParser_PackageName(t *testing.T) {
	p := parser.New()
	result, err := p.AnalyzeFile(taxRulePath)
	require.NoError(t, err)

	assert.Equal(t, "domain", result.Package)
}

// ---------------------------------------------------------------------------
// Generated code detection
// ---------------------------------------------------------------------------

func writeGoFile(t *testing.T, dir, name, content string) string {
	t.Helper()
	path := filepath.Join(dir, name)
	require.NoError(t, os.WriteFile(path, []byte(content), 0644))
	return path
}

func TestGoParser_IsGenerated(t *testing.T) {
	tests := []struct {
		name        string
		source      string
		wantGenFlag bool
	}{
		{
			name: "sqlc generated file",
			source: `// Code generated by sqlc. DO NOT EDIT.
package sqlc

type Customer struct {
	ID   int64
	Name string
}
`,
			wantGenFlag: true,
		},
		{
			name: "protobuf generated file",
			source: `// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api/v1/service.proto

package v1
`,
			wantGenFlag: true,
		},
		{
			name: "normal source file",
			source: `// Package domain contains business logic.
package domain

type User struct {
	Name string
}
`,
			wantGenFlag: false,
		},
		{
			name: "file with DO NOT EDIT but not Code generated",
			source: `// DO NOT EDIT this file manually.
package config
`,
			wantGenFlag: false,
		},
		{
			name: "file with Code generated but not DO NOT EDIT",
			source: `// Code generated by hand.
package manual
`,
			wantGenFlag: false,
		},
		{
			name: "file with no comments",
			source: `package bare

func Hello() string { return "hello" }
`,
			wantGenFlag: false,
		},
	}

	p := parser.New()
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			dir := t.TempDir()
			path := writeGoFile(t, dir, "test.go", tt.source)

			result, err := p.AnalyzeFile(path)
			require.NoError(t, err)
			assert.Equal(t, tt.wantGenFlag, result.IsGenerated,
				"IsGenerated mismatch for: %s", tt.name)
		})
	}
}
