package parser_test

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/openkraft/openkraft/internal/adapters/outbound/parser"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

const taxRulePath = "../../../../testdata/go-hexagonal/perfect/internal/tax/domain/tax_rule.go"
const taxPortsPath = "../../../../testdata/go-hexagonal/perfect/internal/tax/application/tax_ports.go"

func TestGoParser_FindsStructs(t *testing.T) {
	p := parser.New()
	result, err := p.AnalyzeFile(taxRulePath)
	require.NoError(t, err)

	assert.Contains(t, result.Structs, "TaxRule")
}

func TestGoParser_FindsFunctions(t *testing.T) {
	p := parser.New()
	result, err := p.AnalyzeFile(taxRulePath)
	require.NoError(t, err)

	funcNames := make([]string, len(result.Functions))
	for i, f := range result.Functions {
		funcNames[i] = f.Name
	}
	assert.Contains(t, funcNames, "NewTaxRule")
}

func TestGoParser_FindsMethods(t *testing.T) {
	p := parser.New()
	result, err := p.AnalyzeFile(taxRulePath)
	require.NoError(t, err)

	var validateFunc *struct{ name, receiver string }
	for _, f := range result.Functions {
		if f.Name == "Validate" {
			validateFunc = &struct{ name, receiver string }{f.Name, f.Receiver}
			break
		}
	}
	require.NotNil(t, validateFunc, "should find Validate method")
	assert.Equal(t, "*TaxRule", validateFunc.receiver)
}

func TestGoParser_FindsInterfaces(t *testing.T) {
	p := parser.New()
	result, err := p.AnalyzeFile(taxPortsPath)
	require.NoError(t, err)

	assert.Contains(t, result.Interfaces, "TaxRuleRepository")
}

func TestGoParser_ExtractsInterfaceMethods(t *testing.T) {
	p := parser.New()
	af, err := p.AnalyzeFile(taxPortsPath)
	require.NoError(t, err)
	assert.NotEmpty(t, af.InterfaceDefs)
	for _, iface := range af.InterfaceDefs {
		assert.NotEmpty(t, iface.Methods, "interface %s should have methods", iface.Name)
	}
}

func TestGoParser_FindsImports(t *testing.T) {
	p := parser.New()
	result, err := p.AnalyzeFile(taxRulePath)
	require.NoError(t, err)

	assert.Contains(t, result.Imports, "errors")
	assert.Contains(t, result.Imports, "time")
}

func TestGoParser_PackageName(t *testing.T) {
	p := parser.New()
	result, err := p.AnalyzeFile(taxRulePath)
	require.NoError(t, err)

	assert.Equal(t, "domain", result.Package)
}

// ---------------------------------------------------------------------------
// Generated code detection
// ---------------------------------------------------------------------------

func writeGoFile(t *testing.T, dir, name, content string) string {
	t.Helper()
	path := filepath.Join(dir, name)
	require.NoError(t, os.WriteFile(path, []byte(content), 0644))
	return path
}

func TestGoParser_IsGenerated(t *testing.T) {
	tests := []struct {
		name        string
		source      string
		wantGenFlag bool
	}{
		{
			name: "sqlc generated file",
			source: `// Code generated by sqlc. DO NOT EDIT.
package sqlc

type Customer struct {
	ID   int64
	Name string
}
`,
			wantGenFlag: true,
		},
		{
			name: "protobuf generated file",
			source: `// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api/v1/service.proto

package v1
`,
			wantGenFlag: true,
		},
		{
			name: "normal source file",
			source: `// Package domain contains business logic.
package domain

type User struct {
	Name string
}
`,
			wantGenFlag: false,
		},
		{
			name: "file with DO NOT EDIT but not Code generated",
			source: `// DO NOT EDIT this file manually.
package config
`,
			wantGenFlag: false,
		},
		{
			name: "file with Code generated but not DO NOT EDIT",
			source: `// Code generated by hand.
package manual
`,
			wantGenFlag: false,
		},
		{
			name: "file with no comments",
			source: `package bare

func Hello() string { return "hello" }
`,
			wantGenFlag: false,
		},
	}

	p := parser.New()
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			dir := t.TempDir()
			path := writeGoFile(t, dir, "test.go", tt.source)

			result, err := p.AnalyzeFile(path)
			require.NoError(t, err)
			assert.Equal(t, tt.wantGenFlag, result.IsGenerated,
				"IsGenerated mismatch for: %s", tt.name)
		})
	}
}

func TestGoParser_IsGenerated_SecondCommentGroup(t *testing.T) {
	// Terraform-style: copyright header first, generated marker second.
	source := `// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by terraform-plugin-docs. DO NOT EDIT.

package docs
`
	p := parser.New()
	dir := t.TempDir()
	path := writeGoFile(t, dir, "resource.go", source)

	result, err := p.AnalyzeFile(path)
	require.NoError(t, err)
	assert.True(t, result.IsGenerated, "should detect generated marker in second comment group")
}

func TestGoParser_IsGenerated_FilenameConventions(t *testing.T) {
	normalSource := `package gen

func Hello() string { return "hello" }
`
	tests := []struct {
		name        string
		filename    string
		wantGenFlag bool
	}{
		{"_gen.go is generated", "foo_gen.go", true},
		{".pb.go is generated", "service.pb.go", true},
		{"_gen_test.go is NOT generated", "foo_gen_test.go", false},
		{"normal .go is not generated", "foo.go", false},
	}

	p := parser.New()
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			dir := t.TempDir()
			path := writeGoFile(t, dir, tt.filename, normalSource)

			result, err := p.AnalyzeFile(path)
			require.NoError(t, err)
			assert.Equal(t, tt.wantGenFlag, result.IsGenerated, tt.name)
		})
	}
}

// ---------------------------------------------------------------------------
// String literal ratio detection
// ---------------------------------------------------------------------------

func TestGoParser_StringLiteralRatio(t *testing.T) {
	tests := []struct {
		name     string
		source   string
		minRatio float64
		maxRatio float64
	}{
		{
			name: "template function with large string literal",
			source: "package tmpl\n\nfunc bashCompletion() string {\n\treturn `\n" +
				"_complete_bash() {\n" +
				"  local cur prev\n" +
				"  cur=${COMP_WORDS[COMP_CWORD]}\n" +
				"  prev=${COMP_WORDS[COMP_CWORD-1]}\n" +
				"  COMPREPLY=()\n" +
				"  case $prev in\n" +
				"    --output) COMPREPLY=( $(compgen -W 'json text' -- $cur) ) ;;\n" +
				"    *) COMPREPLY=( $(compgen -W '--help --output --verbose' -- $cur) ) ;;\n" +
				"  esac\n" +
				"}\n" +
				"`\n}\n",
			minRatio: 0.7,
			maxRatio: 1.0,
		},
		{
			name: "normal logic function",
			source: `package logic

func Calculate(a, b int) int {
	if a > b {
		return a - b
	}
	for i := 0; i < b; i++ {
		a += i
	}
	return a
}
`,
			minRatio: 0.0,
			maxRatio: 0.1,
		},
	}

	p := parser.New()
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			dir := t.TempDir()
			path := writeGoFile(t, dir, "test.go", tt.source)

			result, err := p.AnalyzeFile(path)
			require.NoError(t, err)
			require.NotEmpty(t, result.Functions)

			fn := result.Functions[0]
			assert.GreaterOrEqual(t, fn.StringLiteralRatio, tt.minRatio,
				"StringLiteralRatio too low for %s", tt.name)
			assert.LessOrEqual(t, fn.StringLiteralRatio, tt.maxRatio,
				"StringLiteralRatio too high for %s", tt.name)
		})
	}
}

// ---------------------------------------------------------------------------
// CGo import detection
// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------
// Switch dispatch metrics
// ---------------------------------------------------------------------------

func TestGoParser_SwitchDispatchMetrics(t *testing.T) {
	// Build a switch with 20 single-line cases.
	var cases strings.Builder
	for i := 0; i < 20; i++ {
		fmt.Fprintf(&cases, "\tcase %d:\n\t\treturn %d\n", i, i)
	}
	source := fmt.Sprintf(`package dispatch

func Dispatch(v int) int {
	switch v {
%s	}
	return -1
}
`, cases.String())

	p := parser.New()
	dir := t.TempDir()
	path := writeGoFile(t, dir, "dispatch.go", source)

	result, err := p.AnalyzeFile(path)
	require.NoError(t, err)
	require.NotEmpty(t, result.Functions)

	fn := result.Functions[0]
	assert.GreaterOrEqual(t, fn.MaxCaseArms, 20, "should detect 20+ case arms")
	assert.LessOrEqual(t, fn.AvgCaseLines, 3.0, "single-line cases should avg <= 3 lines")
}

func TestGoParser_DetectsCGoImport(t *testing.T) {
	source := `package gpu

// #include <stdlib.h>
import "C"
import "unsafe"

func Alloc(size int) unsafe.Pointer {
	return C.malloc(C.size_t(size))
}
`
	p := parser.New()
	dir := t.TempDir()
	path := writeGoFile(t, dir, "gpu.go", source)

	result, err := p.AnalyzeFile(path)
	require.NoError(t, err)
	assert.True(t, result.HasCGoImport, "file with import \"C\" should set HasCGoImport")
}

func TestGoParser_NoCGoImport(t *testing.T) {
	source := `package logic

import "fmt"

func Hello() { fmt.Println("hello") }
`
	p := parser.New()
	dir := t.TempDir()
	path := writeGoFile(t, dir, "logic.go", source)

	result, err := p.AnalyzeFile(path)
	require.NoError(t, err)
	assert.False(t, result.HasCGoImport, "file without import \"C\" should not set HasCGoImport")
}
