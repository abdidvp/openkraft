package parser_test

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/openkraft/openkraft/internal/adapters/outbound/parser"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

const taxRulePath = "../../../../testdata/go-hexagonal/perfect/internal/tax/domain/tax_rule.go"
const taxPortsPath = "../../../../testdata/go-hexagonal/perfect/internal/tax/application/tax_ports.go"

func TestGoParser_FindsStructs(t *testing.T) {
	p := parser.New()
	result, err := p.AnalyzeFile(taxRulePath)
	require.NoError(t, err)

	assert.Contains(t, result.Structs, "TaxRule")
}

func TestGoParser_FindsFunctions(t *testing.T) {
	p := parser.New()
	result, err := p.AnalyzeFile(taxRulePath)
	require.NoError(t, err)

	funcNames := make([]string, len(result.Functions))
	for i, f := range result.Functions {
		funcNames[i] = f.Name
	}
	assert.Contains(t, funcNames, "NewTaxRule")
}

func TestGoParser_FindsMethods(t *testing.T) {
	p := parser.New()
	result, err := p.AnalyzeFile(taxRulePath)
	require.NoError(t, err)

	var validateFunc *struct{ name, receiver string }
	for _, f := range result.Functions {
		if f.Name == "Validate" {
			validateFunc = &struct{ name, receiver string }{f.Name, f.Receiver}
			break
		}
	}
	require.NotNil(t, validateFunc, "should find Validate method")
	assert.Equal(t, "*TaxRule", validateFunc.receiver)
}

func TestGoParser_FindsInterfaces(t *testing.T) {
	p := parser.New()
	result, err := p.AnalyzeFile(taxPortsPath)
	require.NoError(t, err)

	assert.Contains(t, result.Interfaces, "TaxRuleRepository")
}

func TestGoParser_ExtractsInterfaceMethods(t *testing.T) {
	p := parser.New()
	af, err := p.AnalyzeFile(taxPortsPath)
	require.NoError(t, err)
	assert.NotEmpty(t, af.InterfaceDefs)
	for _, iface := range af.InterfaceDefs {
		assert.NotEmpty(t, iface.Methods, "interface %s should have methods", iface.Name)
	}
}

func TestGoParser_FindsImports(t *testing.T) {
	p := parser.New()
	result, err := p.AnalyzeFile(taxRulePath)
	require.NoError(t, err)

	assert.Contains(t, result.Imports, "errors")
	assert.Contains(t, result.Imports, "time")
}

func TestGoParser_PackageName(t *testing.T) {
	p := parser.New()
	result, err := p.AnalyzeFile(taxRulePath)
	require.NoError(t, err)

	assert.Equal(t, "domain", result.Package)
}

// ---------------------------------------------------------------------------
// Generated code detection
// ---------------------------------------------------------------------------

func writeGoFile(t *testing.T, dir, name, content string) string {
	t.Helper()
	path := filepath.Join(dir, name)
	require.NoError(t, os.WriteFile(path, []byte(content), 0644))
	return path
}

func TestGoParser_IsGenerated(t *testing.T) {
	tests := []struct {
		name        string
		source      string
		wantGenFlag bool
	}{
		{
			name: "sqlc generated file",
			source: `// Code generated by sqlc. DO NOT EDIT.
package sqlc

type Customer struct {
	ID   int64
	Name string
}
`,
			wantGenFlag: true,
		},
		{
			name: "protobuf generated file",
			source: `// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api/v1/service.proto

package v1
`,
			wantGenFlag: true,
		},
		{
			name: "normal source file",
			source: `// Package domain contains business logic.
package domain

type User struct {
	Name string
}
`,
			wantGenFlag: false,
		},
		{
			name: "file with DO NOT EDIT but not Code generated",
			source: `// DO NOT EDIT this file manually.
package config
`,
			wantGenFlag: false,
		},
		{
			name: "file with Code generated but not DO NOT EDIT",
			source: `// Code generated by hand.
package manual
`,
			wantGenFlag: false,
		},
		{
			name: "file with no comments",
			source: `package bare

func Hello() string { return "hello" }
`,
			wantGenFlag: false,
		},
	}

	p := parser.New()
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			dir := t.TempDir()
			path := writeGoFile(t, dir, "test.go", tt.source)

			result, err := p.AnalyzeFile(path)
			require.NoError(t, err)
			assert.Equal(t, tt.wantGenFlag, result.IsGenerated,
				"IsGenerated mismatch for: %s", tt.name)
		})
	}
}

func TestGoParser_IsGenerated_SecondCommentGroup(t *testing.T) {
	// Terraform-style: copyright header first, generated marker second.
	source := `// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by terraform-plugin-docs. DO NOT EDIT.

package docs
`
	p := parser.New()
	dir := t.TempDir()
	path := writeGoFile(t, dir, "resource.go", source)

	result, err := p.AnalyzeFile(path)
	require.NoError(t, err)
	assert.True(t, result.IsGenerated, "should detect generated marker in second comment group")
}

func TestGoParser_IsGenerated_FilenameConventions(t *testing.T) {
	normalSource := `package gen

func Hello() string { return "hello" }
`
	tests := []struct {
		name        string
		filename    string
		wantGenFlag bool
	}{
		{"_gen.go is generated", "foo_gen.go", true},
		{".pb.go is generated", "service.pb.go", true},
		{"_gen_test.go is NOT generated", "foo_gen_test.go", false},
		{"normal .go is not generated", "foo.go", false},
	}

	p := parser.New()
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			dir := t.TempDir()
			path := writeGoFile(t, dir, tt.filename, normalSource)

			result, err := p.AnalyzeFile(path)
			require.NoError(t, err)
			assert.Equal(t, tt.wantGenFlag, result.IsGenerated, tt.name)
		})
	}
}

// ---------------------------------------------------------------------------
// String literal ratio detection
// ---------------------------------------------------------------------------

func TestGoParser_StringLiteralRatio(t *testing.T) {
	tests := []struct {
		name     string
		source   string
		minRatio float64
		maxRatio float64
	}{
		{
			name: "template function with large string literal",
			source: "package tmpl\n\nfunc bashCompletion() string {\n\treturn `\n" +
				"_complete_bash() {\n" +
				"  local cur prev\n" +
				"  cur=${COMP_WORDS[COMP_CWORD]}\n" +
				"  prev=${COMP_WORDS[COMP_CWORD-1]}\n" +
				"  COMPREPLY=()\n" +
				"  case $prev in\n" +
				"    --output) COMPREPLY=( $(compgen -W 'json text' -- $cur) ) ;;\n" +
				"    *) COMPREPLY=( $(compgen -W '--help --output --verbose' -- $cur) ) ;;\n" +
				"  esac\n" +
				"}\n" +
				"`\n}\n",
			minRatio: 0.7,
			maxRatio: 1.0,
		},
		{
			name: "normal logic function",
			source: `package logic

func Calculate(a, b int) int {
	if a > b {
		return a - b
	}
	for i := 0; i < b; i++ {
		a += i
	}
	return a
}
`,
			minRatio: 0.0,
			maxRatio: 0.1,
		},
	}

	p := parser.New()
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			dir := t.TempDir()
			path := writeGoFile(t, dir, "test.go", tt.source)

			result, err := p.AnalyzeFile(path)
			require.NoError(t, err)
			require.NotEmpty(t, result.Functions)

			fn := result.Functions[0]
			assert.GreaterOrEqual(t, fn.StringLiteralRatio, tt.minRatio,
				"StringLiteralRatio too low for %s", tt.name)
			assert.LessOrEqual(t, fn.StringLiteralRatio, tt.maxRatio,
				"StringLiteralRatio too high for %s", tt.name)
		})
	}
}

// ---------------------------------------------------------------------------
// CGo import detection
// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------
// Switch dispatch metrics
// ---------------------------------------------------------------------------

func TestGoParser_SwitchDispatchMetrics(t *testing.T) {
	// Build a switch with 20 single-line cases.
	var cases strings.Builder
	for i := 0; i < 20; i++ {
		fmt.Fprintf(&cases, "\tcase %d:\n\t\treturn %d\n", i, i)
	}
	source := fmt.Sprintf(`package dispatch

func Dispatch(v int) int {
	switch v {
%s	}
	return -1
}
`, cases.String())

	p := parser.New()
	dir := t.TempDir()
	path := writeGoFile(t, dir, "dispatch.go", source)

	result, err := p.AnalyzeFile(path)
	require.NoError(t, err)
	require.NotEmpty(t, result.Functions)

	fn := result.Functions[0]
	assert.GreaterOrEqual(t, fn.MaxCaseArms, 20, "should detect 20+ case arms")
	assert.LessOrEqual(t, fn.AvgCaseLines, 3.0, "single-line cases should avg <= 3 lines")
}

func TestGoParser_DetectsCGoImport(t *testing.T) {
	source := `package gpu

// #include <stdlib.h>
import "C"
import "unsafe"

func Alloc(size int) unsafe.Pointer {
	return C.malloc(C.size_t(size))
}
`
	p := parser.New()
	dir := t.TempDir()
	path := writeGoFile(t, dir, "gpu.go", source)

	result, err := p.AnalyzeFile(path)
	require.NoError(t, err)
	assert.True(t, result.HasCGoImport, "file with import \"C\" should set HasCGoImport")
}

// ---------------------------------------------------------------------------
// Cognitive complexity
// ---------------------------------------------------------------------------

func TestGoParser_CognitiveComplexity(t *testing.T) {
	tests := []struct {
		name   string
		source string
		wantCC int
	}{
		{
			name: "no control flow",
			source: `package cc
func Simple() int { return 1 }
`,
			wantCC: 0,
		},
		{
			name: "single if",
			source: `package cc
func F(x int) int {
	if x > 0 { return x }
	return 0
}
`,
			wantCC: 1,
		},
		{
			name: "if-else",
			source: `package cc
func F(x int) int {
	if x > 0 {
		return x
	} else {
		return 0
	}
}
`,
			wantCC: 2, // if=+1, else=+1
		},
		{
			name: "if-elseif-else",
			source: `package cc
func F(x int) int {
	if x > 0 {
		return 1
	} else if x < 0 {
		return -1
	} else {
		return 0
	}
}
`,
			wantCC: 3, // if=+1, else-if=+1, else=+1
		},
		{
			name: "nested if in for",
			source: `package cc
func F(xs []int) int {
	for _, x := range xs {
		if x > 0 {
			return x
		}
	}
	return 0
}
`,
			wantCC: 3, // for=+1(+0 nesting), if=+1(+1 nesting)
		},
		{
			name: "deep nesting",
			source: `package cc
func F(xs []int) int {
	for _, x := range xs {
		if x > 0 {
			if x > 10 {
				return x
			}
		}
	}
	return 0
}
`,
			wantCC: 6, // for=+1, if=+1+1, if=+1+2 = 6
		},
		{
			name: "boolean sequence same operator",
			source: `package cc
func F(a, b, c bool) bool {
	if a && b && c {
		return true
	}
	return false
}
`,
			wantCC: 2, // if=+1, a&&b&&c = 1 sequence
		},
		{
			name: "boolean sequence mixed operators",
			source: `package cc
func F(a, b, c bool) bool {
	if a && b || c {
		return true
	}
	return false
}
`,
			wantCC: 3, // if=+1, &&=+1, ||=+1 (transition)
		},
		{
			name: "goto",
			source: `package cc
func F() {
	goto end
end:
}
`,
			wantCC: 1, // goto=+1
		},
		{
			name: "labeled break",
			source: `package cc
func F() {
outer:
	for i := 0; i < 10; i++ {
		for j := 0; j < 10; j++ {
			break outer
		}
	}
}
`,
			wantCC: 4, // for=+1, for=+1+1, labeled break=+1
		},
		{
			name: "closure increases nesting",
			source: `package cc
func F() {
	fn := func() {
		if true {
		}
	}
	_ = fn
}
`,
			wantCC: 2, // closure nesting=1, if=+1(+1 nesting)
		},
		{
			name: "select statement",
			source: `package cc
func F(ch1, ch2 chan int) {
	select {
	case <-ch1:
	case <-ch2:
	}
}
`,
			wantCC: 1, // select=+1
		},
		{
			name: "type switch",
			source: `package cc
func F(v interface{}) {
	switch v.(type) {
	case int:
	case string:
	}
}
`,
			wantCC: 1, // type switch=+1
		},
		{
			name: "nested select in for",
			source: `package cc
func F(ch chan int) {
	for {
		select {
		case <-ch:
			if true {}
		}
	}
}
`,
			wantCC: 6, // for=+1(nest0), select=+1+1(nest1), if=+1+2(nest2) = 1+2+3
		},
		{
			name: "for with boolean condition",
			source: `package cc
func F(a, b, c bool) {
	for a && b || c {
	}
}
`,
			wantCC: 3, // for=+1, &&=+1, ||=+1 (mixed operators)
		},
		{
			name: "defer with func literal",
			source: `package cc
func F() {
	defer func() {
		if true {}
	}()
}
`,
			wantCC: 2, // closure nesting=1, if=+1(+1 nesting)
		},
	}

	p := parser.New()
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			dir := t.TempDir()
			path := writeGoFile(t, dir, "cc.go", tt.source)

			result, err := p.AnalyzeFile(path)
			require.NoError(t, err)
			require.NotEmpty(t, result.Functions)

			fn := result.Functions[0]
			assert.Equal(t, tt.wantCC, fn.CognitiveComplexity,
				"CognitiveComplexity mismatch for %s", tt.name)
		})
	}
}

// ---------------------------------------------------------------------------
// Normalized tokens for duplication detection
// ---------------------------------------------------------------------------

func TestGoParser_NormalizedTokens_SameStructureSameTokens(t *testing.T) {
	// Two functions with different variable names but same structure should produce
	// the same normalized tokens.
	src1 := `package a
func Foo(x int) int { return x + 1 }
`
	src2 := `package a
func Bar(y int) int { return y + 1 }
`
	p := parser.New()
	dir := t.TempDir()

	path1 := writeGoFile(t, dir, "a.go", src1)
	path2 := writeGoFile(t, dir, "b.go", src2)

	r1, err := p.AnalyzeFile(path1)
	require.NoError(t, err)
	r2, err := p.AnalyzeFile(path2)
	require.NoError(t, err)

	assert.NotEmpty(t, r1.NormalizedTokens)
	assert.Equal(t, r1.NormalizedTokens, r2.NormalizedTokens,
		"same structure with different names should yield identical tokens")
}

func TestGoParser_NormalizedTokens_DifferentStructureDifferentTokens(t *testing.T) {
	src1 := `package a
func Foo(x int) int { return x + 1 }
`
	src2 := `package a
func Bar(x int) int { if x > 0 { return x } else { return -x } }
`
	p := parser.New()
	dir := t.TempDir()

	path1 := writeGoFile(t, dir, "a.go", src1)
	path2 := writeGoFile(t, dir, "b.go", src2)

	r1, err := p.AnalyzeFile(path1)
	require.NoError(t, err)
	r2, err := p.AnalyzeFile(path2)
	require.NoError(t, err)

	assert.NotEqual(t, r1.NormalizedTokens, r2.NormalizedTokens,
		"different structure should yield different tokens")
}

func TestGoParser_NormalizedTokens_CommentsExcluded(t *testing.T) {
	srcWithComments := `package a
// This is a comment
func Foo(x int) int { return x + 1 }
`
	srcWithoutComments := `package a
func Foo(x int) int { return x + 1 }
`
	p := parser.New()
	dir := t.TempDir()

	path1 := writeGoFile(t, dir, "a.go", srcWithComments)
	path2 := writeGoFile(t, dir, "b.go", srcWithoutComments)

	r1, err := p.AnalyzeFile(path1)
	require.NoError(t, err)
	r2, err := p.AnalyzeFile(path2)
	require.NoError(t, err)

	assert.Equal(t, r1.NormalizedTokens, r2.NormalizedTokens,
		"comments should be excluded from normalized tokens")
}

func TestGoParser_NoCGoImport(t *testing.T) {
	source := `package logic

import "fmt"

func Hello() { fmt.Println("hello") }
`
	p := parser.New()
	dir := t.TempDir()
	path := writeGoFile(t, dir, "logic.go", source)

	result, err := p.AnalyzeFile(path)
	require.NoError(t, err)
	assert.False(t, result.HasCGoImport, "file without import \"C\" should not set HasCGoImport")
}
